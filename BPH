Brief Exploration of paralell BPH algorithm.

Akira Hayakawa, Kyoto University.

1. What is BPH?

BPH is a particle-based algorithm for fluid dynamics. This method is quite similar to DSMC so it is easy for you to understand BPH algorithm if you have learned DSMC.

In particle-based algorithm, particles collide during the simulation but BPH does not explicitly express collision because it is too expensive.
As well as DSMC, BPH devide the calculation space into several cells which is thought to be allowed any shaped and collisions always occur predominantly inside each cell. 
BPH call this step relax therefore the algorithm can be written as

  for cell in cells:
    relax(cell)

relax algorithm is rather complicated so I will not explain it.
All you have to remenber is that 
a) we must calculate some values inside each cell such as the sum of the energy and sum of the velocity
b) and any particles in a cell can refer the value.

This can be written as 

  reduce :: [V] -> V as Haskell-lang does.

2. How to parallize it?
Implementing relax algorithm for one cell and iterate over cells is considered easy however it is considered less-effecient for the following reason,

reason = If the number of particles are 10M and the space are devided into 100^3=10M cells, the average number of particle for each cell is only 10. 
         The massively parallel GPU will not be exploited under this typical situation.

Therefore, we must take number of all the particles as the unit of parallization. I call this is "paricle-parallel".
What we are going to implement has type sigunature like

  parallelBPH :: [Paritle] -> [Particle]

Remember, each paritcle are inside some cell that is indexed and we can write function.

  getIdx :: Paricle -> CellIdx

So, if a particle is attributed with some value V and represent CellIdx as K,
since we have to calculate some values for each cell in particle-parallel.
The type signature will be

  calcCellValues :: [(K, V)] -> [(K, V)]

Well, this is nothing but MapReduce.
To implement MapReduce in Thrust library,
combination of
1. transform 
2. sort_by_key = sort particles by its cell index.
3. reduce_by_key
is applicable.

Note that as radix sort algorithm is used in sorting if the type of K <= 8 bytes in Thrust 1.3,
sorting is not as expensive as you imagine.

3. Reference a cell value from inside the cell in particle-parallel.
To get value of a cell from a particle within the cell in a manner of particle-parallel,
we need such function

  refer :: K -> ([K,V]) -> V

This is lookup in Haskell but the difference is that
a) We have to do in parallel.
b) Lookup never fails.

We can use gather algorithm for this purpose.
or permutation_iterator if preferable.

For more detail,
you can read my thesis but it is written in Japanese.
Or ask me by e-mail.
