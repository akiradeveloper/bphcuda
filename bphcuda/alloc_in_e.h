#pragma once

#include <thrust/iterator/transform_iterator.h>
#include <thrust/iterator/constant_iterator.h>
#include <thrust/transform.h>

#include <thrusting/iterator.h>
#include <thrusting/dtype/real.h>
#include <thrusting/dtype/tuple/real.h>
#include <thrusting/iterator/zip_iterator.h>
#include <thrusting/functional.h>

#include <bphcuda/kinetic_e.h>

namespace {
  using thrusting::real;
  using thrusting::real3;
  using thrusting::real5;
}

namespace bphcuda {

/*
  (c, m, s) -> in_e
*/
struct in_e_allocator :public thrust::unary_function<real5, real> {
  __host__ __device__
  real operator()(const real5 &in) const {
    real3 c = real3(in.get<0>(), in.get<1>(), in.get<2>());
    real m = in.get<3>();
    real s = in.get<4>();
    real ratio = s / real(3.0);
    return ratio * bphcuda::calc_kinetic_e(c, m);
  }
};

/*
  Initialization scheme.
  Inner energies are generated by sharing the kinetic energy
  that is allocated by distribution function initially. 
*/
template<typename RealIterator1, typename RealIterator2, typename RealIterator3, typename RealIterator4>
void alloc_in_e(
  size_t n_particle, 
  RealIterator1 u, RealIterator1 v, RealIterator1 w,
  RealIterator2 m,
  RealIterator3 in_e, // output
  RealIterator4 s
){
  thrust::transform(
    thrusting::make_zip_iterator(u, v, w, m, s),
    thrusting::advance(n_particle, thrusting::make_zip_iterator(u, v, w, m, s)),
    in_e,
    in_e_allocator());  
}

} // END bphcuda
